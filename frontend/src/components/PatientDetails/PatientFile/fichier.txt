import React, { useState, useEffect } from "react";
import QuillEditor from "../../QuillEditor.js";

const PatientDiagnosis = ({ motif, updateMotif }) => {
  const [editing, setEditing] = useState(false);
  const [diagnostic, setDiagnostic] = useState(motif?.diagnostic || "");

  useEffect(() => {
    setDiagnostic(motif?.diagnostic || "");
  }, [motif]);

  const handleSave = async () => {
    if (!motif) return;

    const updatedMotif = {
      ...motif,
      diagnostic,
    };

    try {
      await updateMotif(updatedMotif);
      setEditing(false);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde du diagnostic :", error);
    }
  };

  const handleCancel = () => {
    setEditing(false);
    setDiagnostic(motif?.diagnostic || "");
  };

  return (
    <div className="p-4 bg-white shadow-md rounded-lg h-full">
      <h4 className="text-md font-semibold mb-4">Diagnostic</h4>

      {/* ‚úÖ Ajout d'un conteneur propre pour QuillEditor */}
      <div className="border rounded-lg p-2">
        <QuillEditor
          value={diagnostic}
          onChange={setDiagnostic}
          readOnly={!editing}
          className="min-h-[150px] max-h-64 overflow-auto"
        />
      </div>

      <div className="flex space-x-2 mt-4">
        {editing ? (
          <>
            <button className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" onClick={handleSave}>
              Enregistrer
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600" onClick={handleCancel}>
              Annuler
            </button>
          </>
        ) : (
          <button className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600" onClick={() => setEditing(true)}>
            Modifier
          </button>
        )}
      </div>
    </div>
  );
};

export default PatientDiagnosis;
import React, { useState } from "react";
import QuillEditor from "../../QuillEditor.js";

const PatientInterventions = ({ motif, updateMotif }) => {
  const [editingIndex, setEditingIndex] = useState(null);
  const [newIntervention, setNewIntervention] = useState({
    date: "",
    texte: "",
  });
  const [showForm, setShowForm] = useState(false);

  const handleInputChange = (field, value) => {
    setNewIntervention((prev) => ({ ...prev, [field]: value }));
  };

  const handleSaveIntervention = async () => {
    const updatedMotif = {
      ...motif,
      compteRenduInterventions: [
        ...(motif.compteRenduInterventions || []),
        newIntervention,
      ],
    };

    try {
      await updateMotif(updatedMotif);
      setNewIntervention({ date: "", texte: "" });
      setShowForm(false);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde de l'intervention :", error);
    }
  };

  const handleEditIntervention = (index) => {
    setEditingIndex(index);
    setNewIntervention(motif.compteRenduInterventions[index]);
    setShowForm(true);
  };

  const handleSaveEditIntervention = async () => {
    const updatedMotif = {
      ...motif,
      compteRenduInterventions: motif.compteRenduInterventions.map((intervention, index) =>
        index === editingIndex ? newIntervention : intervention
      ),
    };

    try {
      await updateMotif(updatedMotif);
      setEditingIndex(null);
      setNewIntervention({ date: "", texte: "" });
      setShowForm(false);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de l'intervention :", error);
    }
  };

  const handleDeleteIntervention = async (index) => {
    const updatedMotif = {
      ...motif,
      compteRenduInterventions: motif.compteRenduInterventions.filter((_, i) => i !== index),
    };

    try {
      await updateMotif(updatedMotif);
    } catch (error) {
      console.error("Erreur lors de la suppression de l'intervention :", error);
    }
  };

  const handleCancel = () => {
    setEditingIndex(null);
    setNewIntervention({ date: "", texte: "" });
    setShowForm(false);
  };

  return (
    <div className="p-4 bg-white shadow-md rounded-lg">
      <h4 className="text-md font-semibold mb-4">Compte Rendu des Interventions</h4>

      <button
        className="mb-4 bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
        onClick={() => {
          setShowForm(true);
          setEditingIndex(null);
          setNewIntervention({ date: "", texte: "" });
        }}
      >
        Ajouter une intervention
      </button>

      {showForm && (
        <div className="mb-4 border p-4 rounded-lg">
          <input
            type="date"
            className="w-full mb-2 border rounded-lg p-2"
            placeholder="Date de l'intervention"
            value={newIntervention.date}
            onChange={(e) => handleInputChange("date", e.target.value)}
          />
          <QuillEditor
            value={newIntervention.texte}
            onChange={(value) => handleInputChange("texte", value)}
            readOnly={false}
          />
          <div className="flex space-x-2 mt-4">
            {editingIndex !== null ? (
              <>
                <button
                  className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                  onClick={handleSaveEditIntervention}
                >
                  Enregistrer
                </button>
                <button
                  className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                  onClick={handleCancel}
                >
                  Annuler
                </button>
              </>
            ) : (
              <button
                className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                onClick={handleSaveIntervention}
              >
                Ajouter
              </button>
            )}
          </div>
        </div>
      )}

      <div className="mt-4">
        {motif.compteRenduInterventions?.length > 0 ? (
          <ul className="space-y-2">
            {motif.compteRenduInterventions.map((intervention, index) => (
              <li key={index} className="border-b py-2">
                <div className="flex justify-between items-center">
                  <div>
                    <p><strong>Date:</strong> {intervention.date || "Non sp√©cifi√©e"}</p>
                    <div dangerouslySetInnerHTML={{ __html: intervention.texte }} />
                  </div>
                  <div className="flex space-x-2">
                    <button
                      className="text-yellow-500 hover:underline"
                      onClick={() => handleEditIntervention(index)}
                    >
                      ‚úèÔ∏è
                    </button>
                    <button
                      className="text-red-500 hover:underline"
                      onClick={() => handleDeleteIntervention(index)}
                    >
                      üóëÔ∏è
                    </button>
                  </div>
                </div>
              </li>
            ))}
          </ul>
        ) : (
          <p className="text-gray-500">Aucune intervention enregistr√©e.</p>
        )}
      </div>
    </div>
  );
};

export default PatientInterventions;
import React, { useState } from "react";
import QuillEditor from "../../QuillEditor.js";

const PatientObjectives = ({ motif, updateMotif }) => {
  const [selectedLongTermObjective, setSelectedLongTermObjective] = useState(null);
  const [newLongTermObjective, setNewLongTermObjective] = useState({
    titre: "",
  });
  const [newShortTermObjective, setNewShortTermObjective] = useState({
    titre: "",
    dateDebut: "",
    dateFin: "",
    description: "",
    statut: "ouvert",
  });
  const [showShortTermForm, setShowShortTermForm] = useState(false);
  const [editingLongTermObjective, setEditingLongTermObjective] = useState(null);
  const [editingShortTermObjective, setEditingShortTermObjective] = useState(null);

  const handleSelectLongTermObjective = (objective) => {
    setSelectedLongTermObjective(objective);
    setShowShortTermForm(false);
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewShortTermObjective((prev) => ({ ...prev, [name]: value }));
  };

  const handleLongTermInputChange = (e) => {
    const { name, value } = e.target;
    setNewLongTermObjective((prev) => ({ ...prev, [name]: value }));
  };

  const handleSaveShortTermObjective = async () => {
    if (!selectedLongTermObjective) return;

    const updatedMotif = {
      ...motif,
      objectifsCourtTerme: [
        ...(motif.objectifsCourtTerme || []),
        {
          ...newShortTermObjective,
          longTermObjectiveId: selectedLongTermObjective.id,
        },
      ],
    };

    try {
      await updateMotif(updatedMotif);
      setNewShortTermObjective({
        titre: "",
        dateDebut: "",
        dateFin: "",
        description: "",
        statut: "ouvert",
      });
      setShowShortTermForm(false);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde de l'objectif √† court terme :", error);
    }
  };

  const handleSaveLongTermObjective = async () => {
    if (!newLongTermObjective.titre.trim()) return;

    const updatedMotif = {
      ...motif,
      objectifsLongTerme: [
        ...(motif.objectifsLongTerme || []),
        {
          ...newLongTermObjective,
          id: Date.now().toString(), // G√©n√©rer un ID unique pour l'objectif √† long terme
        },
      ],
    };

    try {
      await updateMotif(updatedMotif);
      setNewLongTermObjective({ titre: "" });
    } catch (error) {
      console.error("Erreur lors de la sauvegarde de l'objectif √† long terme :", error);
    }
  };

  const handleEditLongTermObjective = (objective) => {
    setEditingLongTermObjective(objective);
    setNewLongTermObjective({ titre: objective.titre });
  };

  const handleSaveEditLongTermObjective = async () => {
    const updatedMotif = {
      ...motif,
      objectifsLongTerme: motif.objectifsLongTerme.map((obj) =>
        obj.id === editingLongTermObjective.id ? { ...obj, titre: newLongTermObjective.titre } : obj
      ),
    };

    try {
      await updateMotif(updatedMotif);
      setEditingLongTermObjective(null);
      setNewLongTermObjective({ titre: "" });
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de l'objectif √† long terme :", error);
    }
  };

  const handleDeleteLongTermObjective = async (objectiveId) => {
    const updatedMotif = {
      ...motif,
      objectifsLongTerme: motif.objectifsLongTerme.filter((obj) => obj.id !== objectiveId),
      objectifsCourtTerme: motif.objectifsCourtTerme.filter((obj) => obj.longTermObjectiveId !== objectiveId),
    };

    try {
      await updateMotif(updatedMotif);
      setSelectedLongTermObjective(null);
    } catch (error) {
      console.error("Erreur lors de la suppression de l'objectif √† long terme :", error);
    }
  };

  const handleEditShortTermObjective = (objective) => {
    setEditingShortTermObjective(objective);
    setNewShortTermObjective({
      titre: objective.titre,
      dateDebut: objective.dateDebut,
      dateFin: objective.dateFin,
      description: objective.description,
      statut: objective.statut,
    });
    setShowShortTermForm(true);
  };

  const handleSaveEditShortTermObjective = async () => {
    const updatedMotif = {
      ...motif,
      objectifsCourtTerme: motif.objectifsCourtTerme.map((obj) =>
        obj === editingShortTermObjective ? { ...newShortTermObjective, longTermObjectiveId: selectedLongTermObjective.id } : obj
      ),
    };

    try {
      await updateMotif(updatedMotif);
      setEditingShortTermObjective(null);
      setNewShortTermObjective({
        titre: "",
        dateDebut: "",
        dateFin: "",
        description: "",
        statut: "ouvert",
      });
      setShowShortTermForm(false);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de l'objectif √† court terme :", error);
    }
  };

  const handleDeleteShortTermObjective = async (objective) => {
    const updatedMotif = {
      ...motif,
      objectifsCourtTerme: motif.objectifsCourtTerme.filter((obj) => obj !== objective),
    };

    try {
      await updateMotif(updatedMotif);
    } catch (error) {
      console.error("Erreur lors de la suppression de l'objectif √† court terme :", error);
    }
  };

  return (
    <div className="flex space-x-4">
      {/* Liste des objectifs √† long terme */}
      <div className="w-1/3 bg-gray-100 p-4 rounded-lg shadow">
        <h4 className="text-lg font-semibold mb-3">Objectifs Long Terme</h4>
        <div className="mb-4">
          <input
            type="text"
            placeholder="Titre de l'objectif √† long terme"
            value={newLongTermObjective.titre}
            onChange={handleLongTermInputChange}
            name="titre"
            className="w-full p-2 border rounded-lg mb-2"
          />
          {editingLongTermObjective ? (
            <>
              <button
                className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                onClick={handleSaveEditLongTermObjective}
              >
                Enregistrer
              </button>
              <button
                className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 ml-2"
                onClick={() => setEditingLongTermObjective(null)}
              >
                Annuler
              </button>
            </>
          ) : (
            <button
              className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
              onClick={handleSaveLongTermObjective}
            >
              Ajouter
            </button>
          )}
        </div>
        <ul className="space-y-2">
          {motif.objectifsLongTerme?.map((objective, index) => (
            <li
              key={index}
              className={`cursor-pointer p-2 rounded-lg ${
                selectedLongTermObjective?.id === objective.id ? "bg-blue-500 text-white" : "bg-gray-200"
              } hover:bg-blue-300`}
              onClick={() => handleSelectLongTermObjective(objective)}
            >
              <div className="flex justify-between items-center">
                <strong>{objective.titre}</strong>
                <div className="flex space-x-2">
                  <button
                    className="text-yellow-500 hover:underline"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEditLongTermObjective(objective);
                    }}
                  >
                    ‚úèÔ∏è
                  </button>
                  <button
                    className="text-red-500 hover:underline"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDeleteLongTermObjective(objective.id);
                    }}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              </div>
            </li>
          ))}
        </ul>
      </div>

      {/* Formulaire pour cr√©er un objectif √† court terme */}
      <div className="w-2/3 bg-white p-4 rounded-lg shadow">
        {selectedLongTermObjective ? (
          <>
            <div className="flex justify-between items-center mb-4">
              <h4 className="text-lg font-semibold">Objectifs √† Court Terme pour "{selectedLongTermObjective.titre}"</h4>
              <button
                className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
                onClick={() => {
                  setShowShortTermForm(true);
                  setEditingShortTermObjective(null);
                  setNewShortTermObjective({
                    titre: "",
                    dateDebut: "",
                    dateFin: "",
                    description: "",
                    statut: "ouvert",
                  });
                }}
              >
                Ajouter
              </button>
            </div>
            {showShortTermForm ? (
              <>
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700">Titre :</label>
                  <input
                    type="text"
                    name="titre"
                    value={newShortTermObjective.titre}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded-lg"
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700">Date D√©but :</label>
                  <input
                    type="date"
                    name="dateDebut"
                    value={newShortTermObjective.dateDebut}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded-lg"
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700">Date Fin :</label>
                  <input
                    type="date"
                    name="dateFin"
                    value={newShortTermObjective.dateFin}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded-lg"
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700">Description :</label>
                  <QuillEditor
                    value={newShortTermObjective.description}
                    onChange={(value) => handleInputChange({ target: { name: "description", value } })}
                    readOnly={false}
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-sm font-medium text-gray-700">Statut :</label>
                  <select
                    name="statut"
                    value={newShortTermObjective.statut}
                    onChange={handleInputChange}
                    className="w-full p-2 border rounded-lg"
                  >
                    <option value="ouvert">Ouvert</option>
                    <option value="ferm√©">Ferm√©</option>
                  </select>
                </div>
                {editingShortTermObjective ? (
                  <>
                    <button
                      className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                      onClick={handleSaveEditShortTermObjective}
                    >
                      Enregistrer
                    </button>
                    <button
                      className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 ml-2"
                      onClick={() => {
                        setEditingShortTermObjective(null);
                        setShowShortTermForm(false);
                      }}
                    >
                      Annuler
                    </button>
                  </>
                ) : (
                  <button
                    className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
                    onClick={handleSaveShortTermObjective}
                  >
                    Enregistrer
                  </button>
                )}
              </>
            ) : (
              <ul className="space-y-2">
                {motif.objectifsCourtTerme
                  ?.filter((obj) => obj.longTermObjectiveId === selectedLongTermObjective.id)
                  .map((objective, index) => (
                    <li key={index} className="p-2 rounded-lg bg-gray-200">
                      <div className="flex justify-between items-center">
                        <div>
                          <strong>{objective.titre}</strong>
                          <p>Date D√©but: {objective.dateDebut}</p>
                          <p>Date Fin: {objective.dateFin}</p>
                          <p>Description: <span dangerouslySetInnerHTML={{ __html: objective.description }} /></p>
                          <p>Statut: {objective.statut}</p>
                        </div>
                        <div className="flex space-x-2">
                          <button
                            className="text-yellow-500 hover:underline"
                            onClick={() => handleEditShortTermObjective(objective)}
                          >
                            ‚úèÔ∏è
                          </button>
                          <button
                            className="text-red-500 hover:underline"
                            onClick={() => handleDeleteShortTermObjective(objective)}
                          >
                            üóëÔ∏è
                          </button>
                        </div>
                      </div>
                    </li>
                  ))}
              </ul>
            )}
          </>
        ) : (
          <p className="text-gray-500">S√©lectionnez un objectif √† long terme pour cr√©er un objectif √† court terme.</p>
        )}
      </div>
    </div>
  );
};

export default PatientObjectives;
import React, { useState, useEffect } from "react";
import QuillEditor from "../../QuillEditor.js";
import { updateMotifIntervention } from "../../../firebase/patientsFirestore.js"; // üîπ V√©rifie que cet import est correct

const PatientSituation = ({ motif, patientId }) => {
  const [editing, setEditing] = useState(false);
  const [newSituation, setNewSituation] = useState({
    personne: motif?.situationPersonnelle?.personne || "",
    occupation: motif?.situationPersonnelle?.occupation || "",
    environnement: motif?.situationPersonnelle?.environnement || "",
  });

  useEffect(() => {
    setNewSituation({
      personne: motif?.situationPersonnelle?.personne || "",
      occupation: motif?.situationPersonnelle?.occupation || "",
      environnement: motif?.situationPersonnelle?.environnement || "",
    });
  }, [motif]);

  // ‚úÖ Active le mode √©dition
  const handleEdit = () => {
    setEditing(true);
  };

  // ‚ùå Annule l'√©dition et restaure les valeurs initiales
  const handleCancel = () => {
    setEditing(false);
    setNewSituation({
      personne: motif?.situationPersonnelle?.personne || "",
      occupation: motif?.situationPersonnelle?.occupation || "",
      environnement: motif?.situationPersonnelle?.environnement || "",
    });
  };

  // ‚úèÔ∏è Met √† jour localement les valeurs pendant la saisie
  const handleInputChange = (field, value) => {
    setNewSituation((prev) => ({ ...prev, [field]: value }));
  };

  const handleSave = async () => {
    if (!motif || !patientId) {
      console.error("‚ùå patientId ou motif est undefined !");
      return;
    }
  
    const updatedMotif = {
      ...motif,
      situationPersonnelle: {
        personne: newSituation.personne || "",
        occupation: newSituation.occupation || "",
        environnement: newSituation.environnement || "",
      },
    };
  
    console.log("üì§ Tentative d'enregistrement :", patientId, motif.id, updatedMotif);
  
    try {
      const success = await updateMotifIntervention(patientId, motif.id, updatedMotif);
  
      if (success) {
        console.log("‚úÖ Mise √† jour r√©ussie !");
        
        // üõë Ajout : Mise √† jour du `state` pour rafra√Æchir imm√©diatement l'affichage
        setNewSituation(updatedMotif.situationPersonnelle);
        
        // üõë Ajout : Mise √† jour du motif actuel
        motif.situationPersonnelle = updatedMotif.situationPersonnelle;
  
        setEditing(false);
      } else {
        console.error("‚ùå Mise √† jour √©chou√©e.");
      }
    } catch (error) {
      console.error("‚ùå Erreur lors de la mise √† jour :", error);
    }
  };
  

  return (
    <div className="p-4 bg-white shadow-md rounded-lg">
      <h4 className="text-lg font-semibold mb-4">Situation Personnelle</h4>

      {/* ‚úÖ √âditeur pour "Personne" */}
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Personne :</label>
        <QuillEditor
          value={newSituation.personne}
          onChange={(value) => handleInputChange("personne", value)}
          readOnly={!editing}
        />
      </div>

      {/* ‚úÖ √âditeur pour "Occupation" */}
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Occupation :</label>
        <QuillEditor
          value={newSituation.occupation}
          onChange={(value) => handleInputChange("occupation", value)}
          readOnly={!editing}
        />
      </div>

      {/* ‚úÖ √âditeur pour "Environnement" */}
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Environnement :</label>
        <QuillEditor
          value={newSituation.environnement}
          onChange={(value) => handleInputChange("environnement", value)}
          readOnly={!editing}
        />
      </div>

      {/* ‚úÖ Boutons Modifier / Enregistrer / Annuler */}
      <div className="flex space-x-2">
        {!editing ? (
          <button className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600" onClick={handleEdit}>
            Modifier
          </button>
        ) : (
          <>
            <button className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" onClick={handleSave}>
              Enregistrer
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600" onClick={handleCancel}>
              Annuler
            </button>
          </>
        )}
      </div>
    </div>
  );
};

export default PatientSituation;
import React, { useState, useEffect } from "react";
import QuillEditor from "../../QuillEditor.js";

const PatientSummary = ({ motif, updateMotif }) => {
  const [editing, setEditing] = useState(false);
  const [synthese, setSynthese] = useState(motif?.synthese || "");

  useEffect(() => {
    setSynthese(motif?.synthese || "");
  }, [motif]);

  const handleSave = async () => {
    if (!motif) return;

    const updatedMotif = {
      ...motif,
      synthese,
    };

    try {
      await updateMotif(updatedMotif);
      setEditing(false);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde de la synth√®se :", error);
    }
  };

  const handleCancel = () => {
    setEditing(false);
    setSynthese(motif?.synthese || "");
  };

  return (
    <div className="p-4 bg-white shadow-md rounded-lg h-full">
      <h4 className="text-md font-semibold mb-4">Synth√®se</h4>

      <div className="border rounded-lg p-2">
        <QuillEditor
          value={synthese}
          onChange={setSynthese}
          readOnly={!editing}
          className="min-h-[150px] max-h-64 overflow-auto"
        />
      </div>

      <div className="flex space-x-2 mt-4">
        {editing ? (
          <>
            <button className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" onClick={handleSave}>
              Enregistrer
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600" onClick={handleCancel}>
              Annuler
            </button>
          </>
        ) : (
          <button className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600" onClick={() => setEditing(true)}>
            Modifier
          </button>
        )}
      </div>
    </div>
  );
};

export default PatientSummary;
import React, { useState, useEffect } from "react";
import QuillEditor from "../../QuillEditor.js";
import { updateMotifIntervention } from "../../../firebase/patientsFirestore.js";

const PatientTherapeutic = ({ motif, patientId, updateMotif }) => {
  const [editing, setEditing] = useState(false);
  const [therapeuticData, setTherapeuticData] = useState({
    assesments: motif?.perspectiveTherapeutique?.assesments || "",
    syntheseEvaluation: motif?.perspectiveTherapeutique?.syntheseEvaluation || "",
    restrictionsSouhaits: motif?.perspectiveTherapeutique?.restrictionsSouhaits || "",
    diagnosticOccupationnel: motif?.perspectiveTherapeutique?.diagnosticOccupationnel || "",
  });

  useEffect(() => {
    setTherapeuticData({
      assesments: motif?.perspectiveTherapeutique?.assesments || "",
      syntheseEvaluation: motif?.perspectiveTherapeutique?.syntheseEvaluation || "",
      restrictionsSouhaits: motif?.perspectiveTherapeutique?.restrictionsSouhaits || "",
      diagnosticOccupationnel: motif?.perspectiveTherapeutique?.diagnosticOccupationnel || "",
    });
  }, [motif]);

  const handleEdit = () => {
    setEditing(true);
  };

  const handleCancel = () => {
    setEditing(false);
    setTherapeuticData({
      assesments: motif?.perspectiveTherapeutique?.assesments || "",
      syntheseEvaluation: motif?.perspectiveTherapeutique?.syntheseEvaluation || "",
      restrictionsSouhaits: motif?.perspectiveTherapeutique?.restrictionsSouhaits || "",
      diagnosticOccupationnel: motif?.perspectiveTherapeutique?.diagnosticOccupationnel || "",
    });
  };

  const handleInputChange = (field, value) => {
    setTherapeuticData((prev) => ({ ...prev, [field]: value }));
  };

  const handleSave = async () => {
    if (!motif || !patientId) {
      console.error("‚ùå patientId ou motif est undefined !");
      return;
    }

    const updatedMotif = {
      ...motif,
      perspectiveTherapeutique: {
        assesments: therapeuticData.assesments || "",
        syntheseEvaluation: therapeuticData.syntheseEvaluation || "",
        restrictionsSouhaits: therapeuticData.restrictionsSouhaits || "",
        diagnosticOccupationnel: therapeuticData.diagnosticOccupationnel || "",
      },
    };

    console.log("üì§ Sauvegarde des donn√©es th√©rapeutiques :", patientId, updatedMotif);

    try {
      await updateMotifIntervention(patientId, motif.id, updatedMotif);
      console.log("‚úÖ Mise √† jour r√©ussie !");
      setEditing(false);
      updateMotif(updatedMotif); // Update the parent component's state
    } catch (error) {
      console.error("‚ùå Erreur lors de la mise √† jour :", error);
    }
  };

  return (
    <div className="p-4 bg-white shadow-md rounded-lg">
      <h4 className="text-lg font-semibold mb-4">Perspective Th√©rapeutique</h4>

      <div className="mb-4 p-3 border border-gray-300 bg-gray-100 rounded-lg">
        <h5 className="text-md font-semibold text-gray-700">Batteries Code CIF</h5>
        <p className="text-gray-600">{therapeuticData.assesments || "Non d√©fini"}</p>
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Synth√®se de l'√©valuation :</label>
        <QuillEditor
          value={therapeuticData.syntheseEvaluation}
          onChange={(value) => handleInputChange("syntheseEvaluation", value)}
          readOnly={!editing}
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Restrictions de participation :</label>
        <QuillEditor
          value={therapeuticData.restrictionsSouhaits}
          onChange={(value) => handleInputChange("restrictionsSouhaits", value)}
          readOnly={!editing}
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700">Diagnostic Occupationnel :</label>
        <QuillEditor
          value={therapeuticData.diagnosticOccupationnel}
          onChange={(value) => handleInputChange("diagnosticOccupationnel", value)}
          readOnly={!editing}
        />
      </div>

      <div className="flex space-x-2">
        {!editing ? (
          <button className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600" onClick={handleEdit}>
            Modifier
          </button>
        ) : (
          <>
            <button className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" onClick={handleSave}>
              Enregistrer
            </button>
            <button className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600" onClick={handleCancel}>
              Annuler
            </button>
          </>
        )}
      </div>
    </div>
  );
};

export default PatientTherapeutic;
